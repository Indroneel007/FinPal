// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: account.sql

package db

import (
	"context"
	"database/sql"
)

const createAccount = `-- name: CreateAccount :one
INSERT INTO accounts (
  owner, balance, currency, type
) VALUES (
  $1, $2, $3, $4
)
RETURNING id, owner, balance, currency, type, group_id, has_accepted, created_at
`

type CreateAccountParams struct {
	Owner    string `json:"owner"`
	Balance  int64  `json:"balance"`
	Currency string `json:"currency"`
	Type     string `json:"type"`
}

func (q *Queries) CreateAccount(ctx context.Context, arg CreateAccountParams) (Account, error) {
	row := q.db.QueryRowContext(ctx, createAccount,
		arg.Owner,
		arg.Balance,
		arg.Currency,
		arg.Type,
	)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Owner,
		&i.Balance,
		&i.Currency,
		&i.Type,
		&i.GroupID,
		&i.HasAccepted,
		&i.CreatedAt,
	)
	return i, err
}

const createAccountWithGroup = `-- name: CreateAccountWithGroup :one
INSERT INTO accounts (
  owner, balance, currency, type, group_id, has_accepted
) VALUES (
  $1, $2, $3, $4, $5, $6
)
RETURNING id, owner, balance, currency, type, group_id, has_accepted, created_at
`

type CreateAccountWithGroupParams struct {
	Owner       string        `json:"owner"`
	Balance     int64         `json:"balance"`
	Currency    string        `json:"currency"`
	Type        string        `json:"type"`
	GroupID     sql.NullInt64 `json:"group_id"`
	HasAccepted sql.NullBool  `json:"has_accepted"`
}

func (q *Queries) CreateAccountWithGroup(ctx context.Context, arg CreateAccountWithGroupParams) (Account, error) {
	row := q.db.QueryRowContext(ctx, createAccountWithGroup,
		arg.Owner,
		arg.Balance,
		arg.Currency,
		arg.Type,
		arg.GroupID,
		arg.HasAccepted,
	)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Owner,
		&i.Balance,
		&i.Currency,
		&i.Type,
		&i.GroupID,
		&i.HasAccepted,
		&i.CreatedAt,
	)
	return i, err
}

const deleteAccount = `-- name: DeleteAccount :exec
DELETE FROM accounts
WHERE id = $1
`

func (q *Queries) DeleteAccount(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteAccount, id)
	return err
}

const getAccount = `-- name: GetAccount :one
SELECT id, owner, balance, currency, type, group_id, has_accepted, created_at FROM accounts
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetAccount(ctx context.Context, id int64) (Account, error) {
	row := q.db.QueryRowContext(ctx, getAccount, id)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Owner,
		&i.Balance,
		&i.Currency,
		&i.Type,
		&i.GroupID,
		&i.HasAccepted,
		&i.CreatedAt,
	)
	return i, err
}

const getAccountByGroupIDAndOwner = `-- name: GetAccountByGroupIDAndOwner :one
SELECT id, owner, balance, currency, type, group_id, has_accepted, created_at FROM accounts
WHERE group_id = $1 AND owner = $2 LIMIT 1
`

type GetAccountByGroupIDAndOwnerParams struct {
	GroupID sql.NullInt64 `json:"group_id"`
	Owner   string        `json:"owner"`
}

func (q *Queries) GetAccountByGroupIDAndOwner(ctx context.Context, arg GetAccountByGroupIDAndOwnerParams) (Account, error) {
	row := q.db.QueryRowContext(ctx, getAccountByGroupIDAndOwner, arg.GroupID, arg.Owner)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Owner,
		&i.Balance,
		&i.Currency,
		&i.Type,
		&i.GroupID,
		&i.HasAccepted,
		&i.CreatedAt,
	)
	return i, err
}

const getAccountByOwnerCurrencyType = `-- name: GetAccountByOwnerCurrencyType :one
SELECT id, owner, balance, currency, type, group_id, has_accepted, created_at FROM accounts
WHERE owner = $1 AND currency = $2 AND type = $3 LIMIT 1
`

type GetAccountByOwnerCurrencyTypeParams struct {
	Owner    string `json:"owner"`
	Currency string `json:"currency"`
	Type     string `json:"type"`
}

func (q *Queries) GetAccountByOwnerCurrencyType(ctx context.Context, arg GetAccountByOwnerCurrencyTypeParams) (Account, error) {
	row := q.db.QueryRowContext(ctx, getAccountByOwnerCurrencyType, arg.Owner, arg.Currency, arg.Type)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Owner,
		&i.Balance,
		&i.Currency,
		&i.Type,
		&i.GroupID,
		&i.HasAccepted,
		&i.CreatedAt,
	)
	return i, err
}

const getAccountForUpdate = `-- name: GetAccountForUpdate :one
SELECT id, owner, balance, currency, type, group_id, has_accepted, created_at FROM accounts
WHERE id = $1 LIMIT 1
FOR NO KEY UPDATE
`

func (q *Queries) GetAccountForUpdate(ctx context.Context, id int64) (Account, error) {
	row := q.db.QueryRowContext(ctx, getAccountForUpdate, id)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Owner,
		&i.Balance,
		&i.Currency,
		&i.Type,
		&i.GroupID,
		&i.HasAccepted,
		&i.CreatedAt,
	)
	return i, err
}

const getAccountListByOwnerAndType = `-- name: GetAccountListByOwnerAndType :many
SELECT id, owner, balance, currency, type, group_id, has_accepted, created_at FROM accounts
WHERE owner = $1 AND type = $2
ORDER BY id
LIMIT $3 OFFSET $4
`

type GetAccountListByOwnerAndTypeParams struct {
	Owner  string `json:"owner"`
	Type   string `json:"type"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) GetAccountListByOwnerAndType(ctx context.Context, arg GetAccountListByOwnerAndTypeParams) ([]Account, error) {
	rows, err := q.db.QueryContext(ctx, getAccountListByOwnerAndType,
		arg.Owner,
		arg.Type,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Account
	for rows.Next() {
		var i Account
		if err := rows.Scan(
			&i.ID,
			&i.Owner,
			&i.Balance,
			&i.Currency,
			&i.Type,
			&i.GroupID,
			&i.HasAccepted,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalByOwnerAndType = `-- name: GetTotalByOwnerAndType :many
SELECT
  owner,
  type,
  SUM(balance) AS total_balance
FROM
  accounts
WHERE
  owner = $1
GROUP BY
  owner, type
`

type GetTotalByOwnerAndTypeRow struct {
	Owner        string `json:"owner"`
	Type         string `json:"type"`
	TotalBalance int64  `json:"total_balance"`
}

func (q *Queries) GetTotalByOwnerAndType(ctx context.Context, owner string) ([]GetTotalByOwnerAndTypeRow, error) {
	rows, err := q.db.QueryContext(ctx, getTotalByOwnerAndType, owner)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTotalByOwnerAndTypeRow
	for rows.Next() {
		var i GetTotalByOwnerAndTypeRow
		if err := rows.Scan(&i.Owner, &i.Type, &i.TotalBalance); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAccounts = `-- name: ListAccounts :many
SELECT id, owner, balance, currency, type, group_id, has_accepted, created_at FROM accounts
ORDER BY id
LIMIT $1
OFFSET $2
`

type ListAccountsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListAccounts(ctx context.Context, arg ListAccountsParams) ([]Account, error) {
	rows, err := q.db.QueryContext(ctx, listAccounts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Account
	for rows.Next() {
		var i Account
		if err := rows.Scan(
			&i.ID,
			&i.Owner,
			&i.Balance,
			&i.Currency,
			&i.Type,
			&i.GroupID,
			&i.HasAccepted,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAccountsByOwner = `-- name: ListAccountsByOwner :many
SELECT id, owner, balance, currency, type, group_id, has_accepted, created_at FROM accounts
WHERE owner = $1
ORDER BY id
LIMIT $2
OFFSET $3
`

type ListAccountsByOwnerParams struct {
	Owner  string `json:"owner"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) ListAccountsByOwner(ctx context.Context, arg ListAccountsByOwnerParams) ([]Account, error) {
	rows, err := q.db.QueryContext(ctx, listAccountsByOwner, arg.Owner, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Account
	for rows.Next() {
		var i Account
		if err := rows.Scan(
			&i.ID,
			&i.Owner,
			&i.Balance,
			&i.Currency,
			&i.Type,
			&i.GroupID,
			&i.HasAccepted,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactedUsersWithTotals = `-- name: ListTransactedUsersWithTotals :many
SELECT
    other_user::text AS username,
    COALESCE(SUM(CASE WHEN sub.from_account_id = sub.a_id THEN sub.amount END), 0)::bigint AS total_sent,
    COALESCE(SUM(CASE WHEN sub.to_account_id = sub.a_id THEN sub.amount END), 0)::bigint AS total_received
FROM (
    SELECT
        CASE
            WHEN t.from_account_id = a.id THEN a2.owner
            ELSE a.owner
        END AS other_user,
        t.from_account_id,
        t.to_account_id,
        t.amount,
        a.id AS a_id
    FROM transfers t
    JOIN accounts a ON a.owner = $1
    JOIN accounts a2 ON a2.id = t.to_account_id
    WHERE t.from_account_id = a.id OR t.to_account_id = a.id
) sub
GROUP BY other_user
ORDER BY other_user
LIMIT $2 OFFSET $3
`

type ListTransactedUsersWithTotalsParams struct {
	Owner  string `json:"owner"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

type ListTransactedUsersWithTotalsRow struct {
	Username      string `json:"username"`
	TotalSent     int64  `json:"total_sent"`
	TotalReceived int64  `json:"total_received"`
}

func (q *Queries) ListTransactedUsersWithTotals(ctx context.Context, arg ListTransactedUsersWithTotalsParams) ([]ListTransactedUsersWithTotalsRow, error) {
	rows, err := q.db.QueryContext(ctx, listTransactedUsersWithTotals, arg.Owner, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTransactedUsersWithTotalsRow
	for rows.Next() {
		var i ListTransactedUsersWithTotalsRow
		if err := rows.Scan(&i.Username, &i.TotalSent, &i.TotalReceived); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAccountGroup = `-- name: UpdateAccountGroup :one
UPDATE accounts
  set group_id = NULL
WHERE id = $1
RETURNING id, owner, balance, currency, type, group_id, has_accepted, created_at
`

func (q *Queries) UpdateAccountGroup(ctx context.Context, id int64) (Account, error) {
	row := q.db.QueryRowContext(ctx, updateAccountGroup, id)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Owner,
		&i.Balance,
		&i.Currency,
		&i.Type,
		&i.GroupID,
		&i.HasAccepted,
		&i.CreatedAt,
	)
	return i, err
}

const updateAcount = `-- name: UpdateAcount :one
UPDATE accounts
  set balance = $2
WHERE id = $1
RETURNING id, owner, balance, currency, type, group_id, has_accepted, created_at
`

type UpdateAcountParams struct {
	ID      int64 `json:"id"`
	Balance int64 `json:"balance"`
}

func (q *Queries) UpdateAcount(ctx context.Context, arg UpdateAcountParams) (Account, error) {
	row := q.db.QueryRowContext(ctx, updateAcount, arg.ID, arg.Balance)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Owner,
		&i.Balance,
		&i.Currency,
		&i.Type,
		&i.GroupID,
		&i.HasAccepted,
		&i.CreatedAt,
	)
	return i, err
}
